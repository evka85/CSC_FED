<?xml version="1.0" encoding="ISO-8859-1"?>
<!--  The tags attribute is a free test attribute which meaning is defined by the uHAL user -->
<node id="top">
  <node id="CSC_FED">

    <!--TTC module -->
    <node id="TTC"  address="0x00300000"
          description="TTC control and monitoring. It takes care of locking to the TTC clock coming from the backplane as well as decoding TTC commands and forwarding that to all other modules in the design. It also provides several control and monitoring registers (resets, command decoding configuration, clock and data status, bc0 status, command counters and a small spy buffer)"
          fw_is_module="true"
          fw_module_file="../common/hdl/ttc/ttc.vhd"
          fw_user_clock_signal="clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="5"
          fw_reg_addr_lsb="0">
        <node id="CTRL" address="0x0" description="TTC control">
            <node id="MODULE_RESET" address="0x0" mask="0x80000000" permission="w" description="TTC module reset"
                  fw_write_pulse_signal="ttc_ctrl.reset_local"/>
            <node id="MMCM_RESET" address="0x1" mask="0x40000000" permission="w" description="TTC MMCM reset"
                  fw_write_pulse_signal="ttc_ctrl.mmcm_reset"/>
            <node id="CNT_RESET" address="0x2" mask="0x20000000" permission="w" description="TTC counter reset"
                  fw_write_pulse_signal="ttc_ctrl.cnt_reset"
                  sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
            <node id="MMCM_PHASE_SHIFT" address="0x3" mask="0x10000000" permission="w" description="TTC MMCM phase shift trigger"
                  fw_write_pulse_signal="ttc_ctrl.mmcm_phase_shift"/>
            <node id="L1A_ENABLE" address="0x4" mask="0x00000001" permission="rw" description="Enable L1As (L1As are blocked if this is 0)"
                  fw_signal="ttc_ctrl.l1a_enable" fw_default="0b1"
                  sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x1" sw_ctrl_stop_set="0x0"/>
        </node>
        <node id="CONFIG" address="0x5" description="TTC configuration -- used for setup TTC command decoding">
            <node id="CMD_BC0" address="0x0" mask="0x000000ff" permission="rw" description="BC0 command code"
                  fw_signal="ttc_conf.cmd_bc0" fw_default="0x01"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_EC0" address="0x0" mask="0x0000ff00" permission="rw" description="EC0 command code"
                  fw_signal="ttc_conf.cmd_ec0" fw_default="0x02"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_RESYNC" address="0x0" mask="0x00ff0000" permission="rw" description="Resync command code"
                  fw_signal="ttc_conf.cmd_resync" fw_default="0x04"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_OC0" address="0x0" mask="0xff000000" permission="rw" description="OC0 command code"
                  fw_signal="ttc_conf.cmd_oc0" fw_default="0x08"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_HARD_RESET" address="0x1" mask="0x000000ff" permission="rw" description="Hard-reset command code"
                  fw_signal="ttc_conf.cmd_hard_reset" fw_default="0x10"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_CALPULSE" address="0x1" mask="0x0000ff00" permission="rw" description="Calibration pulse command code"
                  fw_signal="ttc_conf.cmd_calpulse" fw_default="0x14"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_START" address="0x1" mask="0x00ff0000" permission="rw" description="START command code"
                  fw_signal="ttc_conf.cmd_start" fw_default="0x18"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_STOP" address="0x1" mask="0xff000000" permission="rw" description="STOP command code"
                  fw_signal="ttc_conf.cmd_stop" fw_default="0x1c"
                  sw_ctrl_configure_confdb_check_set="true"/>
            <node id="CMD_TEST_SYNC" address="0x2" mask="0x000000ff" permission="rw" description="Test-sync command code"
                  fw_signal="ttc_conf.cmd_test_sync" fw_default="0x20"
                  sw_ctrl_configure_confdb_check_set="true"/>
        </node>
        <node id="STATUS" address="0x8" description="TTC status">
            <node id="MMCM_LOCKED" address="0x0" mask="0x00000001" permission="r" description="MMCM locked flag"
                  fw_signal="ttc_status.mmcm_locked"
                  sw_monitor_error_value="0"/>
            <node id="TTC_SINGLE_ERROR_CNT" address="0x1" mask="0x0000ffff" permission="r" description="TTC stream single bit error count"
                  fw_signal="ttc_status.single_err"
                  sw_monitor_warn_min_threshold="1"/>
            <node id="TTC_DOUBLE_ERROR_CNT" address="0x1" mask="0xffff0000" permission="r" description="TTC stream double bit error count"
                  fw_signal="ttc_status.double_err"
                  sw_monitor_error_min_threshold="1"/>
            <node id="BC0" address="0x2" description="TTC status">
                <node id="LOCKED" address="0x0" mask="0x00000001" permission="r" description="BC0 locked flag"
                      fw_signal="ttc_status.bc0_status.locked"
                      sw_monitor_error_value="0"/>
                <node id="UNLOCK_CNT" address="0x1" mask="0x0000ffff" permission="r" description="BC0 unlock count"
                      fw_signal="ttc_status.bc0_status.unlocked_cnt"
                      sw_monitor_error_min_threshold="1"/>
                <node id="OVERFLOW_CNT" address="0x2" mask="0x0000ffff" permission="r" description="BX counter overflow count (late or no BC0 received)"
                      fw_signal="ttc_status.bc0_status.ovf_cnt"
                      sw_monitor_error_min_threshold="1"/>
                <node id="UNDERFLOW_CNT" address="0x2" mask="0xffff0000" permission="r" description="BX counter underflow count (early BC0 received, one is normal after the TTC module reset, but this should be reset by control software before each run)"
                      fw_signal="ttc_status.bc0_status.udf_cnt"
                      sw_monitor_error_min_threshold="1"/>
            </node>
        </node>

        <node id="CMD_COUNTERS" address="0xd" description="TTC command counters">
            <node id="L1A" address="0x0" mask="0xffffffff" permission="r" description="L1A count"
                  fw_signal="ttc_cmds_cnt_arr(0)"/>
            <node id="BC0" address="0x1" mask="0xffffffff" permission="r" description="BC0 count"
                  fw_signal="ttc_cmds_cnt_arr(1)"/>
            <node id="EC0" address="0x2" mask="0xffffffff" permission="r" description="EC0 count"
                  fw_signal="ttc_cmds_cnt_arr(2)"/>
            <node id="RESYNC" address="0x3" mask="0xffffffff" permission="r" description="Resync count"
                  fw_signal="ttc_cmds_cnt_arr(3)"/>
            <node id="OC0" address="0x4" mask="0xffffffff" permission="r" description="OC0 count"
                  fw_signal="ttc_cmds_cnt_arr(4)"/>
            <node id="HARD_RESET" address="0x5" mask="0xffffffff" permission="r" description="Hard-reset count"
                  fw_signal="ttc_cmds_cnt_arr(5)"/>
            <node id="CALPULSE" address="0x6" mask="0xffffffff" permission="r" description="Calibration pulse count"
                  fw_signal="ttc_cmds_cnt_arr(6)"/>
            <node id="START" address="0x7" mask="0xffffffff" permission="r" description="START count"
                  fw_signal="ttc_cmds_cnt_arr(7)"/>
            <node id="STOP" address="0x8" mask="0xffffffff" permission="r" description="STOP count"
                  fw_signal="ttc_cmds_cnt_arr(8)"/>
            <node id="TEST_SYNC" address="0x9" mask="0xffffffff" permission="r" description="Test-sync count"
                  fw_signal="ttc_cmds_cnt_arr(9)"/>
        </node>

        <node id="L1A_ID" address="0x17" mask="0x00ffffff" permission="r"
              description="L1A ID (increments with every L1A and resets with EC0), used by DAQ to tag event numbers"
              fw_signal="l1id_cnt"/>

        <node id="L1A_RATE" address="0x18" mask="0xffffffff" permission="r"
              description="L1A rate in Hz"
              fw_signal="l1a_rate"/>

        <node id="TTC_SPY_BUFFER" address="0x19" mask="0xffffffff" permission="r" description="TTC Spy buffer -- this is filled with TTC commands (from LSB to MSB) and freezes until the user reads it out, once read out it resets and fills up again with new TTC commands received from that point on"
              fw_signal="ttc_spy_buffer" fw_read_pulse_signal="ttc_spy_reset"/>
    </node>
    <!--end TTC module -->

    <!-- System module -->
    <node id="SYSTEM"  address="0x00100000"
          description="This module is controlling CSC FED system wide settings"
          fw_is_module="true"
          fw_module_file="../common/hdl/system/system_regs.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">

        <node id="BOARD_ID" address="0x2" mask="0x0000ffff" permission="rw"
              description="Board ID that gets embedded in the AMC13 header"
              fw_signal="board_id" fw_default="0xcfed"/>
        <node id="BOARD_TYPE" address="0x2" mask="0x000f0000" permission="r"
              description="Board type: 1 means CTP7"
              fw_signal="board_type"/>
              
        <node id="RELEASE" address="0x3">
            <node id="MAJOR" address="0x0" mask="0x00ff0000" permission="r"
                  description="Firmware release major version"
                  fw_signal="std_logic_vector(to_unsigned(version_major, 8))"/>
            <node id="MINOR" address="0x0" mask="0x0000ff00" permission="r"
                  description="Firmware release minor version"
                  fw_signal="std_logic_vector(to_unsigned(version_minor, 8))"/>
            <node id="BUILD" address="0x0" mask="0x000000ff" permission="r"
                  description="Firmware release build version"
                  fw_signal="std_logic_vector(to_unsigned(version_build, 8))"/>
            <node id="DATE" address="0x1" mask="0xffffffff" permission="r"
                  description="Firmware release date (read as hex)"
                  fw_signal="firmware_date"/>
        </node>      
        
        <node id="CONFIG" address="0x5">
            <node id="NUM_OF_DMBS" address="0x0" mask="0x000000ff" permission="r"
                  description="Number of DMB inputs supported in this build"
                  fw_signal="num_of_dmbs"/>
        </node>

    </node>
    <!--end System module -->
    
    <!-- Link monitor module -->
    <node id="LINKS"  address="0x00200000"
          description="Link monitoring registers"
          fw_is_module="true"
          fw_module_file="../common/hdl/system/link_monitor.vhd"
          fw_user_clock_signal="clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">
          
        <node id="CTRL" address="0x0" description="Link monitor control">
            <node id="CNT_RESET" address="0x0" mask="0x80000000" permission="w" description="Counter reset"
                  fw_write_pulse_signal="reset_local"/>
        </node>

        <node id="DMB${DMB_IDX}" address="0x10" description="Link(s) of DMB ${DMB_IDX}"
              generate="true" generate_size="2" generate_address_step="0x10" generate_idx_var="DMB_IDX">
            <node id="MGT_BUF_OVF_CNT" address="0x0" mask="0x0000ffff" permission="r"
                  description="Number of times that MGT elastic buffer has been in overflow"
                  fw_signal="dmb_mgt_buf_ovf_arr(${DMB_IDX})"
                  sw_monitor_warn_min_threshold="1"/>
            <node id="MGT_BUF_UNF_CNT" address="0x0" mask="0xffff0000" permission="r"
                  description="Number of times that MGT elastic buffer has been in underflow"
                  fw_signal="dmb_mgt_buf_unf_arr(${DMB_IDX})"
                  sw_monitor_warn_min_threshold="1"/>
            <node id="CLK_CORR_ADD_CNT" address="0x1" mask="0x0000ffff" permission="r"
                  description="Number of times that MGT has added a fake idle word to correct for clock drift"
                  fw_signal="dmb_clk_corr_add_arr(${DMB_IDX})"/>
            <node id="CLK_CORR_DROP_CNT" address="0x1" mask="0xffff0000" permission="r"
                  description="Number of times that MGT has dropped an idle word to correct for clock drift"
                  fw_signal="dmb_clk_corr_drop_arr(${DMB_IDX})"/>
            <node id="NOT_IN_TABLE_CNT" address="0x2" mask="0x0000ffff" permission="r"
                  description="Number of not-in-table errors"
                  fw_signal="dmb_not_in_table_arr(${DMB_IDX})"
                  sw_monitor_warn_min_threshold="1000"/>
            <node id="DISPERR_CNT" address="0x2" mask="0xffff0000" permission="r"
                  description="Number of disparity errors"
                  fw_signal="dmb_disperr_arr(${DMB_IDX})"
                  sw_monitor_warn_min_threshold="1000"/>
        </node>

        <node id="SPY" address="0xa00" description="Spy readout link">
            <node id="MGT_BUF_OVF_CNT" address="0x0" mask="0x0000ffff" permission="r"
                  description="Number of times that MGT elastic buffer has been in overflow"
                  fw_signal="spy_mgt_buf_ovf"
                  sw_monitor_warn_min_threshold="1"/>
            <node id="MGT_BUF_UNF_CNT" address="0x0" mask="0xffff0000" permission="r"
                  description="Number of times that MGT elastic buffer has been in underflow"
                  fw_signal="spy_mgt_buf_unf"
                  sw_monitor_warn_min_threshold="1"/>
            <node id="CLK_CORR_ADD_CNT" address="0x1" mask="0x0000ffff" permission="r"
                  description="Number of times that MGT has added a fake idle word to correct for clock drift"
                  fw_signal="spy_clk_corr_add"/>
            <node id="CLK_CORR_DROP_CNT" address="0x1" mask="0xffff0000" permission="r"
                  description="Number of times that MGT has dropped an idle word to correct for clock drift"
                  fw_signal="spy_clk_corr_drop"/>
            <node id="NOT_IN_TABLE_CNT" address="0x2" mask="0x0000ffff" permission="r"
                  description="Number of not-in-table errors"
                  fw_signal="spy_not_in_table"
                  sw_monitor_warn_min_threshold="1000"/>
            <node id="DISPERR_CNT" address="0x2" mask="0xffff0000" permission="r"
                  description="Number of disparity errors"
                  fw_signal="spy_disperr"
                  sw_monitor_warn_min_threshold="1000"/>
        </node>

    </node>
    <!--end link monitor module -->

    <!--DAQ module -->
    <node id="DAQ"  address="0x00400000"
          description="DAQ module buffers track data, builds events, analyses the data for consistency and ships off the events with all the needed headers and trailers to AMC13 over DAQLink"
          fw_is_module="true"
          fw_module_file="../common/hdl/daq/daq.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="8"
          fw_reg_addr_lsb="0">
          
        <node id="CONTROL"  address="0x0" description="DAQ Control">
            <node id="DAQ_ENABLE"         address="0x0" mask="0x00000001" permission="rw"
                  description="If this is set to 0, there will be no data sent to AMC13 and TTS state will always be READY (0x8)"
                  fw_signal="daq_enable" fw_default="0b0"/>
            <node id="IGNORE_AMC13"         address="0x0" mask="0x00000002" permission="rw"
                  description="If this is set to 1 then there will be no data sent to AMC13, but events will still be built and sent to spy path ignoring AMC13 DAQLink state"
                  fw_signal="ignore_amc13" fw_default="0b0"/>
            <node id="DAQ_LINK_RESET"     address="0x0" mask="0x00000004" permission="rw"
                  description="Directly connected to DAQLink module reset port. BU is
                               advising against ever using it except for powerup, but it
                               may clear some error conditions (like daqlink_almost_ful
                               stuck at 1). AMC13 reset is probably required after this."
                  fw_signal="reset_daqlink_ipb" fw_default="0b0"/>
            <node id="RESET"              address="0x0" mask="0x00000008" permission="rw"
                  description="Clears all FIFOs, state flags and counters. It also stops and
                               resets all state machines (no events will be built, recorded
                               or sent during reset)
                               When set to 1, it will be held in reset state until 0 is
                               explicitly written (this can be changed in the future if
                               necessary)"
                  fw_signal="reset_local" fw_default="0b0"/>
            <node id="TTS_OVERRIDE"       address="0x0" mask="0x000000f0" permission="rw"
                  description="When not 0, it will override the GLIB TTS state with the
                               provided value (e.g. writing 0x8 will force GLIB to always be
                               in TTS READY state)"
                  fw_signal="tts_override" fw_default="0x0"/>
            <node id="INPUT_ENABLE_MASK"  address="0x0" mask="0xffffff00" permission="rw"
                  description="This is a bitmask telling GLIB to enable certain inputs (least
                               significant bit is input 0). Only first is enabled by default"
                  fw_signal="input_mask" fw_default="0x1"/>
            <node id="DAV_TIMEOUT"        address="0x6"  mask="0x00ffffff" permission="rw"
                  description="This setting controls how long DAQ will wait for individual
                               inputs to report data before calling it timed-out  (if timeout
                               occurs a header and trailer for that chamber will still be
                               inserted and timeout flag will be set there, though no VFAT
                               payload will be present). Units = clock cycles @ 25MHz
                               (current DAQLink clk frequency)"
                  fw_signal="dav_timeout" fw_default="0x3d090"/>
        </node>
        
        <node id="STATUS"  address="0x1" description="DAQ global status registers">
            <node id="DAQ_LINK_RDY"    address="0x0"  mask="0x00000001" permission="r"
                  description="When this is 1, it means that GLIB is in good communication
                               with AMC13. It must be 1 for GLIB to be able to send data."
                  fw_signal="daq_ready"/>
            <node id="DAQ_CLK_LOCKED"  address="0x0"  mask="0x00000002" permission="r"
                  description="This flag is 1 if DAQ clock is locked at this moment"
                  fw_signal="daq_clk_locked_i"/>
            <node id="TTC_RDY"         address="0x0"  mask="0x00000004" permission="r"
                  description="This flag is 1 if TTC clock MMCM is locked"
                  fw_signal="ttc_status_i.mmcm_locked"/>
            <node id="DAQ_LINK_AFULL"       address="0x0"  mask="0x00000008" permission="r"
                  description="This bit comes directly from DAQLink module, indicating
                               that its internal buffers are almost full. No events will be sent
                               when this bit is 1 (though events can still be built and
                               stored in the Input and Event FIFOs)"
                  fw_signal="daq_almost_full"
                  sw_monitor_error_min_threshold="1"/>
            <node id="DAQ_OUTPUT_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00000010" permission="r"
                  description="This bit is set if DAQ output FIFO has ever been full (critical -- data loss)"
                  fw_signal="err_daqfifo_full"
                  sw_monitor_error_min_threshold="1"/>
            <node id="TTC_BC0_LOCKED"       address="0x0"  mask="0x00000020" permission="r"
                  description="This bit is set if BC0 is currently locked (last BC0 arrived at the expected time)"
                  fw_signal="ttc_status_i.bc0_status.locked"/>
            <node id="L1A_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00800000" permission="r"
                  description="This bit is latched whenever L1A FIFO overflow is asserted.
                               This means that one or more L1As were lost, so we are
                               out-of-sync: resync or reset is needed"
                  fw_signal="err_l1afifo_full"
                  sw_monitor_error_min_threshold="1"/>
            <node id="L1A_FIFO_IS_UNDERFLOW"       address="0x0"  mask="0x01000000" permission="r"
                  description="L1A FIFO is in underflow at this moment (this bit is not latched)"
                  fw_signal="l1afifo_underflow"
                  sw_monitor_error_min_threshold="1"/>
            <node id="L1A_FIFO_IS_FULL"       address="0x0"  mask="0x02000000" permission="r"
                  description="L1A FIFO is full at this moment (this bit is not latched)"
                  fw_signal="l1afifo_full"
                  sw_monitor_error_min_threshold="1"/>
            <node id="L1A_FIFO_IS_NEAR_FULL"       address="0x0"  mask="0x04000000" permission="r"
                  description="This bit gets asserted when L1A FIFO gets 75% full and deasserted when it gets down to 50%"
                  fw_signal="l1afifo_near_full"/>
            <node id="L1A_FIFO_IS_EMPTY"       address="0x0"  mask="0x08000000" permission="r"
                  description="L1A FIFO is empty at this moment (this bit is not latched)"
                  fw_signal="l1afifo_empty"/>
            <node id="TTS_STATE"       address="0x0"  mask="0xf0000000" permission="r"
                  description="Current TTS state (READY, BUSY, ERROR, WARN, OUT-OF-SYNC)"
                  fw_signal="tts_state"/>
        </node>
        
        <node id="EXT_STATUS"  address="0x2" description="DAQ global extended status registers">
            <node id="NOTINTABLE_ERR"  address="0x0"  mask="0x0000ffff" permission="r"
                  description="This counter is counting DAQLink GTX/GTH not-in-table errors"
                  fw_signal="daq_notintable_err_cnt"/>
            <node id="DISPER_ERR"      address="0x1"  mask="0x0000ffff" permission="r"
                  description="This counter is counting DAQLink GTX/GTH dispersion errors"
                  fw_signal="daq_disper_err_cnt"/>
            <node id="L1AID"           address="0x2"  mask="0x00ffffff" permission="r"
                  description="Current L1A ID (similar to event number, but this may be a bit ahead of that if we're still waiting for data for unprocessed L1As)"
                  fw_signal="ttc_daq_cntrs_i.l1id"/>
            <node id="EVT_SENT"        address="0x3"  mask="0xffffffff" permission="r"
                  description="Number of events shipped out to DAQLink"
                  fw_signal="std_logic_vector(cnt_sent_events)"/>
            <node id="MAX_DAV_TIMER"   address="0x5"  mask="0x00ffffff" permission="r"
                  description="This indicates the maximum amount of time that DAQ had
                               to wait for all inputs to report data (can be used to optimize
                               DAV timeout setting). Units = clock cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)
                               (current DAQLink clk frequency)"
                  fw_signal="std_logic_vector(max_dav_timer)"/>
            <node id="LAST_DAV_TIMER"  address="0x6"  mask="0x00ffffff" permission="r"
                  description="This indicates how DAQ had to wait for all inputs to report
                               data for the last event (mostly for debugging). Units = clock
                               cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)"
                  fw_signal="std_logic_vector(last_dav_timer)"/>
            <node id="L1A_FIFO_DATA_CNT"  address="0x7"  mask="0x00001fff" permission="r"
                  description="Current number of words in the L1A FIFO (current depth is 8192)"
                  fw_signal="l1afifo_data_cnt"/>
            <node id="DAQ_FIFO_DATA_CNT"  address="0x7"  mask="0x1fff0000" permission="r"
                  description="Current number of words in the DAQ output FIFO (current depth is 8192)"
                  fw_signal="daqfifo_data_cnt"/>
            <node id="L1A_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0x0000ffff" permission="r"
                  description="Number of clocks L1A FIFO was near-full (asserted at 75%, deasserted at 50%)"
                  fw_signal="l1afifo_near_full_cnt"
                  sw_monitor_warn_min_threshold="100"/>
            <node id="DAQ_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0xffff0000" permission="r"
                  description="Number of clocks DAQ output FIFO was near-full (asserted at 75%, deasserted at 50%)"
                  fw_signal="daqfifo_near_full_cnt"
                  sw_monitor_warn_min_threshold="100"/>
            <node id="DAQ_ALMOST_FULL_CNT"  address="0x9"  mask="0x0000ffff" permission="r"
                  description="Number of clocks DAQLink has asserted almost-full flag"
                  fw_signal="daqlink_afull_cnt"/>
            <node id="TTS_WARN_CNT"  address="0x9"  mask="0xffff0000" permission="r"
                  description="Number of clocks we reported TTS WARNING state"
                  fw_signal="tts_warning_cnt"
                  sw_monitor_warn_min_threshold="100"/>
            <node id="DAQ_WORD_RATE"  address="0xa"  mask="0xffffffff" permission="r"
                  description="Rate of 64bit words being sent out to the DAQLink in Hz (multiply by 64 to get bitrate)"
                  fw_signal="daq_word_rate"
                  sw_monitor_warn_min_threshold="40000"/> <!-- currently running DAQ at 50MHz, which is 3.2Gbs, so warning at 2.5Gbs (could increase to 80MHz to get 5Gbs) -->
        </node>

        <node id="EXT_CONTROL"  address="0xd" description="DAQ global extended configuration registers">
            <node id="RUN_TYPE"       address="0x0"  mask="0x0f000000" permission="rw"
                  description="User settable run type that gets embedded into the AMC header"
                  fw_signal="run_type" fw_default="0x0"/>
            <node id="RUN_PARAMS"     address="0x0"  mask="0x00ffffff" permission="rw"
                  description="User settable run params that gets embedded into the AMC header"
                  fw_signal="run_params" fw_default="0x000000"/>
        </node>
        
        <node id="LAST_EVENT_FIFO"  address="0xe" description="DAQ last event fifo (read 32 bits at a time). This is only filled by DAQ when empty.">
            <node id="EMPTY"       address="0x0"  mask="0x00000001" permission="r"
                  description="Fifo is empty"
                  fw_signal="last_evt_fifo_empty"/>
            <node id="DATA"     address="0x1"  mask="0xffffffff" permission="r"
                  description="32bits of last event data"
                  fw_signal="last_evt_fifo_dout" fw_read_pulse_signal="last_evt_fifo_rd_en" fw_read_ready_signal="last_evt_fifo_valid"/>
        </node>

        <node id="DMB${DMB_IDX}"  address="0x10"
              description="Link specific registers for DMB${DMB_IDX}"
              generate="true" generate_size="2" generate_address_step="0x10" generate_idx_var="DMB_IDX">
            
            <!--node id="CONTROL"  address="0x0">
            </node-->

            <node id="STATUS"  address="0x0">
                <node id="INPUT_FIFO_HAD_OFLOW"   mask="0x00000100" permission="r" address="0x0"
                      description="Critical: Input FIFO overflow occurred.
                                   This bit is latched if Input FIFO was ever full when receiving
                                   new data - this means data was lost.
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${DMB_IDX}).err_infifo_full"/>
                <node id="INPUT_FIFO_HAD_UFLOW"   mask="0x00000200" permission="r" address="0x0"
                      description="Critical: Input FIFO underflow occurred.
                                   This bit is latched if Input FIFO underflow was ever
                                   detected. This means that Event FIFO indicated that there
                                   should be more data than was stored in Input FIFO. This
                                   might happen due to overflow or some other malfunction.
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${DMB_IDX}).err_infifo_underflow"/>
                <node id="EVENT_FIFO_HAD_OFLOW"   mask="0x00000400" permission="r" address="0x0"
                      description="Critical: Event FIFO overflow occurred.
                                   This bit is latched if Event FIFO was ever full when trying to
                                   build a new event. This means data was lost.
                                   It's not likely that this will ever be asserted because Input
                                   FIFO should overflow first.
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${DMB_IDX}).err_evtfifo_full"/>
                <node id="EVT_SIZE_ERR"           mask="0x00000800" permission="r" address="0x0"
                      description="Critical: Event size overflow occurred.
                                   This bit is latched if there was an event containing more
                                   than 4096 words. Input FIFO and Event FIFO will be
                                   out-of-sync. This might happen if end-of-event is not
                                   detected properly or for whatever reason AMC is receiving
                                   a stream of valid data.
                                   TTS ERROR is asserted when this bit is 1"
                      fw_signal="input_status_arr(${DMB_IDX}).err_event_too_big"/>
                <node id="TTS_STATE"           mask="0x0000f000" permission="r" address="0x0"
                      description="Input TTS state (gets integrated into global TTS state later)"
                      fw_signal="input_status_arr(${DMB_IDX}).tts_state"/>
                <node id="INPUT_FIFO_IS_UFLOW"    mask="0x01000000" permission="r" address="0x0"
                      description="Current status: Input FIFO is in underflow"
                      fw_signal="input_status_arr(${DMB_IDX}).infifo_underflow"/>
                <node id="INPUT_FIFO_IS_FULL"     mask="0x02000000" permission="r" address="0x0"
                      description="Current status: Input FIFO is full"
                      fw_signal="input_status_arr(${DMB_IDX}).infifo_full"/>
                <node id="INPUT_FIFO_IS_AFULL"    mask="0x04000000" permission="r" address="0x0"
                      description="Current status: Input FIFO is near-full (asserted at 75% and deasserted at 50%)"
                      fw_signal="input_status_arr(${DMB_IDX}).infifo_near_full"/>
                <node id="INPUT_FIFO_IS_EMPTY"    mask="0x08000000" permission="r" address="0x0"
                      description="Current status: Input FIFO is empty"
                      fw_signal="input_status_arr(${DMB_IDX}).infifo_empty"/>
                <node id="EVENT_FIFO_IS_UFLOW"    mask="0x10000000" permission="r" address="0x0"
                      description="Current status: Event FIFO is in underflow"
                      fw_signal="input_status_arr(${DMB_IDX}).evtfifo_underflow"/>
                <node id="EVENT_FIFO_IS_FULL"     mask="0x20000000" permission="r" address="0x0"
                      description="Current status: Event FIFO is full"
                      fw_signal="input_status_arr(${DMB_IDX}).evtfifo_full"/>
                <node id="EVENT_FIFO_IS_AFULL"    mask="0x40000000" permission="r" address="0x0"
                      description="Current status: Event FIFO is near-full (asserted at 75% and deasserted at 50%)"
                      fw_signal="input_status_arr(${DMB_IDX}).evtfifo_near_full"/>
                <node id="EVENT_FIFO_IS_EMPTY"    mask="0x80000000" permission="r" address="0x0"
                      description="Current status: Event FIFO is empty"
                      fw_signal="input_status_arr(${DMB_IDX}).evtfifo_empty"/>
            </node>

            <node id="COUNTERS">
                <node id="EVN"                   address="0x2" mask="0x00ffffff" permission="r"
                      description="Current event number of the event builder.
                                   This counter starts at 1 and increments with each
                                   end-of-event detection. This number should be similar to
                                   the number of events sent to AMC13 in normal operation,
                                   but it might not always be exactly the same because there's
                                   some latency between building an event and sending it. In
                                   addition, event sending could stop due to DAQ FIFO being
                                   almost full or DAQLink not being ready."
                      fw_signal="input_status_arr(${DMB_IDX}).eb_event_num"/>
                <node id="INPUT_FIFO_DATA_CNT"  address="0x4"  mask="0x00003fff" permission="r"
                      description="Current number of words in the Input FIFO (current depth is 4096)"
                      fw_signal="chamber_infifos(${DMB_IDX}).data_cnt"/>
                <node id="EVT_FIFO_DATA_CNT"  address="0x4"  mask="0x0fff0000" permission="r"
                      description="Current number of words in the Event FIFO (current depth is 4096)"
                      fw_signal="chamber_evtfifos(${DMB_IDX}).data_cnt"/>                      
                <node id="INPUT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0x0000ffff" permission="r"
                      description="Number of times Input FIFO was near-full (asserted at 75%, deasserted at 50%)"
                      fw_signal="input_status_arr(${DMB_IDX}).infifo_near_full_cnt"
                      sw_monitor_warn_min_threshold="100"/>
                <node id="EVT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0xffff0000" permission="r"
                      description="Number of times Event FIFO was near-full (asserted at 75%, deasserted at 50%)"
                      fw_signal="input_status_arr(${DMB_IDX}).evtfifo_near_full_cnt"
                      sw_monitor_warn_min_threshold="100"/>
                <node id="DATA_WORD_RATE"  address="0x6"  mask="0x00007fff" permission="r"
                      description="Rate of valid 64bit data words being written to Input FIFO in Hz (multiply by 64 to get bitrate)"
                      fw_signal="input_status_arr(${DMB_IDX}).infifo_wr_rate"
                      sw_monitor_warn_min_threshold="13000"/>
                <node id="EVT_RATE"  address="0x6"  mask="0xffff8000" permission="r"
                      description="Rate of events being written to Event FIFO in Hz"
                      fw_signal="input_status_arr(${DMB_IDX}).evtfifo_wr_rate"/>                      
            </node>

        </node>
    </node>
    <!-- end of DAQ module -->
        
  </node>
</node>
